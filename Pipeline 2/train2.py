import torchfrom torch.utils.data import DataLoader, random_splitfrom tqdm import tqdmfrom config import Config, TRAIN_DIRfrom dataset import BraTS2DSmartDataset, train_transformfrom model import ResUNet2Dfrom losses import CombinedLossfrom metrics import dice_scoreds = BraTS2DSmartDataset(TRAIN_DIR, "train", train_transform)train_sz = int(0.9 * len(ds))train_ds, val_ds = random_split(ds, [train_sz, len(ds)-train_sz])train_loader = DataLoader(train_ds, batch_size=Config["BATCH_SIZE"], shuffle=True)val_loader = DataLoader(val_ds, batch_size=Config["BATCH_SIZE"])model = ResUNet2D().to(Config["DEVICE"])opt = torch.optim.AdamW(model.parameters(), lr=Config["LR"])crit = CombinedLoss()scaler = torch.amp.GradScaler("cuda")best = 0for e in range(Config["EPOCHS"]):    model.train()    for x,y in tqdm(train_loader):        x,y = x.to(Config["DEVICE"]), y.to(Config["DEVICE"])        with torch.amp.autocast("cuda"):            loss = crit(model(x), y)        opt.zero_grad()        scaler.scale(loss).backward()        scaler.step(opt)        scaler.update()    model.eval()    d = 0    with torch.no_grad():        for x,y in val_loader:            p = model(x.to(Config["DEVICE"])).argmax(1)            d += dice_score(p, y.to(Config["DEVICE"]))    d /= len(val_loader)    if d > best:        best = d        torch.save(model.state_dict(), "best_model.pth")