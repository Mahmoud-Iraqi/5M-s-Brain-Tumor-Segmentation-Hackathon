import osimport numpy as npimport nibabel as nibimport torchfrom torch.utils.data import Datasetimport cv2import albumentations as Afrom config import Configtrain_transform = A.Compose([    A.Rotate(limit=35, p=0.5),    A.HorizontalFlip(p=0.5),    A.VerticalFlip(p=0.5),    A.RandomBrightnessContrast(p=0.2),    A.ElasticTransform(alpha=120, sigma=6, alpha_affine=4, p=0.3)])class BraTS2DSmartDataset(Dataset):    def __init__(self, root_dir, phase="train", transform=None):        self.root_dir = root_dir        self.phase = phase        self.transform = transform        all_ids = sorted([d for d in os.listdir(root_dir) if "BraTS2021" in d])        self.patient_ids = all_ids[-Config["TARGET_PATIENTS"]:]        np.random.shuffle(self.patient_ids)    def __len__(self):        return len(self.patient_ids) * Config["SLICES_PER_PATIENT"]    def find_nii(self, path):        for f in os.listdir(path):            if f.endswith(".nii") or f.endswith(".nii.gz"):                return os.path.join(path, f)    def __getitem__(self, idx):        pidx = idx // Config["SLICES_PER_PATIENT"]        pid = self.patient_ids[pidx]        ppath = os.path.join(self.root_dir, pid)        seg = nib.load(self.find_nii(ppath))        depth = seg.shape[2]        if self.phase == "train" and np.random.rand() < 0.7:            vol = seg.get_fdata()            idxs = np.where(np.any(vol > 0, axis=(0,1)))[0]            s = np.random.choice(idxs) if len(idxs) else np.random.randint(0, depth)        else:            s = np.random.randint(int(depth*0.1), int(depth*0.9))        mask = seg.dataobj[..., s].astype(np.int64)        mask[mask == 4] = 3        imgs = []        for m in ["flair","t1","t1ce","t2"]:            img = nib.load(self.find_nii(ppath)).dataobj[..., s]            imgs.append(img)        img = np.stack(imgs, -1).astype(np.float32)        img = cv2.resize(img, (Config["IMG_SIZE"],)*2)        mask = cv2.resize(mask, (Config["IMG_SIZE"],)*2, interpolation=cv2.INTER_NEAREST)        for c in range(4):            ch = img[...,c]            if ch[ch>0].size:                p1,p99 = np.percentile(ch[ch>0],[1,99])                img[...,c] = np.clip((ch-p1)/(p99-p1+1e-6),0,1)        if self.phase=="train" and self.transform:            aug = self.transform(image=img, mask=mask)            img, mask = aug["image"], aug["mask"]        return torch.tensor(img).permute(2,0,1), torch.tensor(mask)