import torchimport torch.nn as nnimport torch.nn.functional as Ffrom config import Configclass DiceLoss(nn.Module):    def __init__(self, smooth=1.0):        super().__init__()        self.smooth = smooth    def forward(self, pred, target):        target_oh = F.one_hot(target, num_classes=pred.size(1)).permute(0,3,1,2).float()        pred = F.softmax(pred, dim=1)        inter = (pred * target_oh).sum(dim=(2,3))        union = pred.sum(dim=(2,3)) + target_oh.sum(dim=(2,3))        dice = (2*inter + self.smooth) / (union + self.smooth)        return 1 - dice.mean()class CombinedLoss(nn.Module):    def __init__(self):        super().__init__()        weights = torch.tensor([0.05, 2.5, 2.0, 3.0]).to(Config["DEVICE"])        self.ce = nn.CrossEntropyLoss(weight=weights)        self.dice = DiceLoss()    def forward(self, pred, target):        return 0.4 * self.ce(pred, target) + 0.6 * self.dice(pred, target)